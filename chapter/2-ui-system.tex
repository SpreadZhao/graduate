\chapter{Android 绘制系统}

Android 系统底层采用 Skia，OpenGL 等引擎进行绘制，而在上层封装好的组件就是 Canvas 和 View 。View绘制系统是 Android 开发者最常用到的 UI 编写 API，同时各种动画、自定义样式等绘制操作也都是交由 View 和 Canvas 来完成。

本课题用到的优化机制，主要是针对 View 的，因此这里着重介绍一下 View 的绘制流程。在 Android 应用中，View 占据了一块屏幕上的矩形区域。在这个区域内，UI 将被显示给用户，同时这块区域也负责处理用户、应用本身输入的事件，从而和用户进行交互。View 的体系非常庞大，绘制系统也非常复杂。这里主要针对 View 的大致分类和普通 View 的绘制流程进行说明。

\section{View 的分类}

从总体的功能上看，View 只分为两种：普通的 View 以及 ViewGroup。顾名思义，ViewGroup是用来承载其它 View 和 ViewGroup 的容器；而普通的 View 无法承载其它的 View，只能作为直接和用户交互的组件。在 Android 系统中，View 体系通过树形结构来存储，因此，这棵树上所有的非叶子节点都是 ViewGroup，所有的叶子节点都是普通的 View。

从代码层面来看，ViewGroup 继承自 View，因此 ViewGroup 有着和普通的 View 相似的行为，也需要进行绘制和布局等流程。只不过，ViewGroup 更加关心的是自己内部的子 View 的测量流程，对它们进行统一的管理。

从内容层级来看，Android 应用程序从最顶层的 DecorView 出发（DecorView 本身被 ViewRootImpl 持有），到持有内容的容器 contentParent，最后到应用开发者主动向 Window 中添加的各种 View。这些系统级别的 View 一部分是为了管理系统的应用以及悬浮窗等 Window 的通用行为，另一部分是为了给开发者提供额外的扩展能力。因此，我们对于 View 的性能进行优化，主要优化的也是开发者自行添加的这一部分。

\section{View 的绘制流程}

要明确 Android 体系中 View 的渲染、绘制流程，需要先明确在 Android 系统中的屏幕刷新原理。这样才能对 View 本身的绘制有比较深刻的理解。同时，这里也会介绍卡顿情况产生的原因。后续我们会针对这些问题进行优化。

\subsection{Android 屏幕刷新原理}

在 Android 系统中，屏幕的显示操作需要靠三个部分来完成：CPU，GPU 和显示器。其中，CPU 负责进行绘制信息的计算，其中就包括之后我们介绍的 View 的绘制流程。这些计算好的信息会交给 GPU 进行图形渲染，生成每一个屏幕像素点的颜色信息，并存储到一个缓存当中。当需要让显示器进行显示时，GPU 和显示器的缓存会进行交换，这样显示器得到的就是新的要显示的内容。下面针对屏幕刷新的情况介绍一些概念：

\begin{itemize}
    \item 屏幕刷新率：一秒内屏幕刷新的次数。由于显示器拿到的每一个缓存都包含了屏幕上所有要更新的信息，因此屏幕的显示模式永远是固定的时间将屏幕上的所有像素点进行更新。不过某些情况下，如果前后两次的像素是一致的，那么可以选择不更新，但是这个操作取决于显示器。因此，即使我们提高了 GPU 将像素信息传送到显示器的速度，屏幕刷新率也是不变的，因为这个指标是对于显示器性能的衡量，而非实际情况；
    \item 逐行扫描：显示器显示像素的原理并不是一次性将缓存中所有的像素点真正更新到屏幕上，而是逐行进行扫描。因此，这段扫描的时间决定了显示器的素质。通常情况下， Android 手机的显示器扫描一次整个屏幕需要约16.67毫秒。因此，这个时间的结果就是屏幕每秒钟刷新的次数约为60次，也就是屏幕刷新率为60Hz；
    \item 帧率：与屏幕刷新率相对的，帧率表示实际情况下我们传送给显示器的速度。对于运行在 Android 系统的 CPU 来说，这个过程交给了应用的主线程。因此，如果主线程在执行任务的时候过于耗时，没能及时将数据传递给 GPU 和显示器，那么就会让这一帧无法显示在屏幕上，导致屏幕上显示的还是原来的像素，这就是卡顿产生的原因。因此，为了保证真实的帧率能够贴近屏幕刷新率，Android 应用的主线程在处理任务时应该尽可能快，这样才能保证所有的绘制操作顺利进行并最终显示在屏幕上。
\end{itemize}

在某些情况下，屏幕的显示可能会产生抖动。产生这种现象的原因是，当显示器读取缓存，并显示到屏幕上时，GPU 正在向缓存中写入数据。由于并没有做读写保护，所以前后的像素点并不是来自于同一帧。因此后果就是屏幕上的画面产生了撕裂感。解决这种问题的方法是使用双缓存。也就是 GPU 写入的缓存，和显示器读取的缓存并不是同一个。GPU 永远只写入 Back Buffer，显示器只读取 Frame Buffer。而到了需要刷新的时机时，两个缓存的引用会进行交换。由于这个交换的过程非常快，因此可以杜绝绝大部分的画面撕裂问题。

下一个问题，就是两个缓存进行交换的时机。如果无法保证交换时的读写安全，那么依然会产生显示上的问题。当屏幕的最后一个像素显示完毕后，设备需要一段空闲时间，以便将指针移动回第一个像素来显示下一帧的内容。这段空闲的时间叫做 Vertical Blanking Interval。在这段时间内，屏幕上的内容依然会保持原装，并且显示器也不会去读缓存中的内容。因此，这个时间就是进行缓存交换的最佳时刻。

\subsection{Choreographer 和屏幕信号进行同步}

\subsection{View 的测量、布居和绘制}