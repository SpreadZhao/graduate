\chapter{问题分析和技术选型}

想要优化从滑动屏幕到用户感知卡片刷新的时间，我们不能仅仅通过正面优化绑定的行为来缩短耗时。事实上，业界内已经有一些在合适的时机进行预渲染的手段，同时也不会影响原来的生命周期分发。然而基于 RecyclerView 的 Feed 流并没有提供这样的能力。根本原因是 RecyclerView 更多还是用于处理非粘性滑动的大量图文类型的 Feed 流。因此，我们希望能够给已经在业务方面严重耦合了 RecyclerView 的 Feed 流提供预渲染的能力，提高流畅性体验。

经过调研，目前在 Android 移动端能够实现预渲染的手段主要有以下几种：

\begin{enumerate}
    \item 使用 ViewPager2 来实现预渲染，并且能够简单的封装得到完整的生命周期分发；
    \item 将 RecyclerView 的高度修改为原屏幕高度的2倍，让不可见的那部分承载预加载的 View；
    \item 通过 LayoutManager 设置额外的布局空间，从而在布局过程中多布局一部分。
\end{enumerate}

下面针对当前 Feed 流的业务场景，分析这些优化手段。首先，如果通过重构为 ViewPager2 来实现预渲染，会损失很多 RecyclerView 的灵活性，同时由于在优化项目启动时往往业务逻辑已经非常繁重，所以不可能在短时间内进行大规模的重构；而如果选择将屏幕高度修改为原来的2倍，缺点也非常明显。原本 RecyclerView 在滑动的过程中只需要维护当前 View 和新滑入的 View，在静止时只需要维护正在播放的 View。然而在修改之后需要维护的 View 个数明显增加，导致业务逻辑更加繁重，并且其它业务方（如播放器，交互，弹幕，推荐系统等）都需要做不同程度的适配。这样做的工作量也是非常大的。

因此，最终我们选择第3种方案，也就是通过 LayoutManager 提供的额外布局能力来实现预渲染。这样对 RecyclerView 本身的改动非常小，同时也只是将数据绑定的时机提前。不过，这样的改动依然会对业务造成不小的影响，所以需要对改动带来的副作用进行全方位的排查并进行适配。