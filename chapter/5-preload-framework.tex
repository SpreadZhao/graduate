\chapter{预渲染框架}

\section{背景}

目前，越来越多的互联网产品在移动端上增加“短视频”功能，如快手、抖音、美团、西瓜视频、小红书等等，并且短视频板块在这些应用中通常都处于启动的默认引导场景，即 Feed 流，是整个应用平均消费时间最长的板块。因此，这部分的流畅性体验对于用户的留存，消费时长等指标至关重要。能够优化视频起播的速度、滑动的流畅度、网络请求速度等任何一个场景，都能带来非常大的业务收益。本节主要针对基于 RecyclerView 搭建的短视频场景的 Feed 流进行流畅性的优化。

在这样的场景下，通常 RecyclerView 的一个子 View 作为一个视频的载体。当用户向下滑动时，下一个视频由于被滑动到屏幕内，会进行布局和数据绑定，从而显示在屏幕上。这里面主要的信息有视频的封面图片、视频标题、作者信息等等。从用户的感官角度看，当该子 View 被滑动到屏幕中央定位完毕时，视频会进行播放，此时用户可以对视频的进度，播放速度等进行控制。同时能够通过点赞、评论、收藏等方式进行交互。

对于下一个视频信息的加载过程，通常是需要格外小心的。因为该过程发生在用户滑动屏幕的时候，此时主线程正在不停地根据滑动的事件来进行布局，UI 刷新等操作。这些操作占据了主线程很大一部分资源。因此如果这个时候数据绑定的流程过于复杂，会严重增加这段时间的主线程耗时，从而影响整体的流畅性，甚至造成肉眼可见的卡顿。因此，在 Adapter 进行数据绑定的过程中，是强烈不建议在主线程进行任何耗时任务的。这些任务要么通过异步的方式后续进行补齐，要么针对具体的业务，寻找合适的时机提前进行。

然而，经过业务的不断迭代，数据绑定的耗时一定会随着业务方不断添加新的功能而增加。因此，我们希望能够对这个过程进行彻底的优化。也就是能够直接在一个合适的时机将整个数据绑定操作提前进行，而不是针对业务只异步化其中的一小部分。这样的行为会让 RecyclerView 的生命周期产生混乱，因此即使能够做到，也需要经过细致的修复来让其能够准确地派发原先的生命周期。

\section{Feed 流现状}

基于 RecyclerView 所搭建的视频类型 Feed 流，通常需要进行如下定制：

\begin{enumerate}
    \item 将 RecyclerView 的缓存关闭，因为会影响生命周期派发，导致业务埋点上报混乱；
    \item 将 LayoutManager 的预取功能关闭，该功能会影响数据绑定的生命周期派发。
\end{enumerate}

接下来详细说明这两个功能需要关闭的原因。RecyclerView 的缓存机制是一种对离开屏幕的数据的暂时保护。当一个子 View 因为滑动而脱离屏幕可见范围时，理论上应该被回收，并用于接下来新出现的 View 的数据绑定。但是用户也有可能会重新向反方向滑动，让这些 View 重新显示在屏幕上。因此将这些暂时脱离屏幕的 View 放入缓存中，能够让这些数据保存下来避免被回收，这样重新显示时就不需要再次进行绑定，从而提高流畅性。然而，对于视频类型的应用来说，用户反而向上滑动的操作数量会少很多，反映到数据上就是 RecyclerView 的缓存命中率非常低。同时，增加了缓存，当 View 重新显示时由于不需要绑定，开发者也没有任何手段通过 SDK 获取 View 从缓存中被取出的时机，因此这些 View 的曝光埋点也就无法进行上报。所以对于视频类型的 Feed 流，缓存通常会被关闭，当 View 重新显示时依然进行绑定操作。业务方会依赖这些绑定事件，在进行数据绑定的同时上报曝光埋点，表示该子 View 已经对用户可见，代表着一次用户的消费行为；LayoutManager 的预取功能需要关闭也是同样的原因。预取会导致接下来即将出现的 View 被提前绑定，从而让曝光埋点错误上报。因为我们没有一个比较好的时机去确定当前 View 是否对用户可见，所以只能选择最接近的绑定时机。

在这样的条件下，只有当卡片因为滑动出现在屏幕内时，才会进行数据绑定。这就导致从用户的滑动行为开始到视图真正对用户可见的过程中出现可感知的耗时。这段时间越长，用户就越容易产生卡顿的感觉。

\section{问题分析和技术选型}

想要优化这段时间，我们不能仅仅通过正面优化绑定的行为来缩短耗时。事实上，业界内已经有一些在合适的时机进行预渲染的手段，同时也不会影响原来的生命周期分发。然而基于 RecyclerView 的 Feed 流并没有提供这样的能力。根本原因是 RecyclerView 更多还是用于处理非粘性滑动的大量图文类型的 Feed 流。因此，我们希望能够给已经在业务方面严重耦合了 RecyclerView 的 Feed 流提供预渲染的能力，提高流畅性体验。

经过调研，目前在 Android 移动端能够实现预渲染的手段主要有以下几种：

\begin{enumerate}
    \item 使用 ViewPager2 来实现预渲染，并且能够得到完整的生命周期分发；
    \item 将 RecyclerView 的高度修改为原屏幕高度的2倍，让不可见的那部分承载预加载的 View；
    \item 通过 LayoutManager 提供的额外布局能力进行额外布局。
\end{enumerate}

针对当前 Feed 流的业务场景，分析这些优化手段。首先，如果通过重构为 ViewPager2 来实现预渲染，会损失很多 RecyclerView 的灵活性，同时由于在优化项目启动时往往业务逻辑已经非常繁重，所以不可能在段时间内进行大规模的重构；而如果选择将屏幕高度修改为原来的2倍，缺点也非常明显。原本 RecyclerView 在滑动的过程中只需要维护当前 View 和新滑入的 View，在静止时只需要维护正在播放的View。然而在修改之后需要维护的 View 个数明显增加，导致业务逻辑更加繁重，并且其它业务方（如播放器，交互，弹幕，推荐系统等）都需要做不同程度的适配。这样的工作量也是非常大的。

因此，最终我们选择第3种方案，也就是通过 LayoutManager 提供的额外布局能力来实现预渲染。这样对 RecyclerView 本身的改动非常小，同时也只是将数据绑定的时机提前。不过，这样的改动依然会对业务造成不小的影响，所以需要对改动带来的副作用进行全方位的排查并进行适配。

\section{预渲染框架整体介绍}

预渲染框架整体分为两部分：经过修改的 PreloadLinearLayoutManager 和派发卡片可见性事件的 ViewHolderVisibilityDispatcher。前者主要是替代原有的 LinearLayoutManager，用于实现多种模式的预渲染。同时也对一些由于预加载导致的异常情况进行了修正；后者是由于原来的数据绑定无法再被用于确定卡片是否对用户可见，从而引入的新的生命周期分发器。业务方可以通过注册卡片的可见性来进行监听，并将原来依赖于数据绑定的行为（如曝光埋点）迁移至新的回调方法中。下面对于两个组件的具体结构进行说明。

\subsection{实现预渲染逻辑}

LinearLayoutManager 允许提供额外的布局空间，来处理布局过程中对对超出屏幕的部分进行布局的特殊要求。方式是通过重写 getExtraLayoutSpace() 方法或者 calculateExtraLayoutSpace() 方法。其中前者只能向一个方向进行布局，后者可以在两个方向进行布局。但是，如果采用后者的话，没有引入 AndroidX 1.1.0 的项目无法使用。所以使用兼容性更强的 getExtraLayoutSpace()。

在该方法中，可以返回一个整型变量来标识需要额外布局多长的布局空间。因为我们需要额外布局一张卡片（也就是下一个视频的信息），所以返回的距离应该为一张卡片的高度。通常情况下，卡片的宽高信息可以直接通过 LayoutManager 获取到，高度通常为屏幕的高度。

通过这个简单的操作，就已经能够实现预渲染的核心逻辑，并且经过验证已经可以提前绑定下一张卡片的数据。然而，验证目前的生命周期，我们可以发现，这样的行为其实和没有预渲染并没有什么不同。我们通过一个例子来进行说明：当前卡片为卡片1，在这个情况下，卡片2会因为额外布局空间也被绑定并创建 View 的实例。这样确实能够达到预渲染的效果；然而，如果用户开始向下滑动，在滑动的一瞬间就会因为额外布局空间，将卡片3也提前创建并绑定。这样的结果和没有预渲染没有什么不同，都是在滑动的过程中进行数据的绑定，耗时逻辑依然会影响主线程的性能。所以，我们需要对额外布局空间进行限制，只有在空闲时刻才允许额外的布局空间。反映到业务方就是，选择一个更好的时机去进行预渲染。

为此，设计了若干种预渲染模式，来应对不同业务的需求。主要分为：

\begin{itemize}
    \item 没有预渲染（默认情况）；
    \item 永远预渲染；
    \item 滚动停止时触发预渲染；
    \item 通过外界触发预渲染。
\end{itemize}

其中，通过外界触发预渲染的模式还可以分为有超时补发机制和没有超时补发机制。在有超时补发机制的版本中，当滚动停止时，如果外界没有立刻进行预渲染调用，那么就会提交一个默认为5秒的任务。当到达规定时间时外界依然没有触发预渲染，那么就会补发一次预渲染来应对一些异常情况。想要让 LayoutManager 在这些不同的预渲染模式中自如切换是需要经过缜密的设计和严谨的测试的，接下来介绍为了迎合不同的模式进行的工作。

RecyclerView 会分发滚动状态的变化。RecyclerView 的滚动状态一共有三种：

\begin{itemize}
    \item SCROLL\_STATE\_IDLE：静止状态；
    \item SCROLL\_STATE\_DRAGGING：滚动状态，不过是用户将手放在屏幕上时；
    \item SCROLL\_STATE\_SETTLING：滚动状态，用户松手后，还会滑动一段距离直到停止。这段过程的状态就是 SETTLING。
\end{itemize}

当 RecyclerView 处理用户的触摸事件时，会根据具体情况设置滚动状态的标记位，并通过回调方法派发滚动状态改变的生命周期。因此我们可以在回调中监听到新的滚动状态，并针对具体的预渲染模式进行预渲染的派发。当渲染模式为滚动停止触发预渲染时，如果检测到已经滚动停止，那么应该移除已经存在的预渲染任务，并手动提交一次新的预渲染任务；当预渲染模式为带有超时补发机制的外界触发预渲染时，如果检测到滚动停止，那么会在规定的超时事件后手动提交一次新的预渲染任务。

加入了这些回调逻辑之后，需要对 LayoutManager 的 getExtraLayoutSpace() 做进一步特殊处理。由于我们不会永远预渲染，返回的额外布局空间就不会是一个定值。我们需要针对不同的预渲染模式，根据具体的情况进行判断。如果是滚动停止触发预渲染的模式，只有在当前 RecyclerView 不为滚动状态时才返回额外的布局空间，否则返回默认值0；如果是外界触发的预渲染，那么绝大多数情况都应该返回默认值，只有外界触发预渲染的那一刻才返回额外的布局空间用于预渲染。

以上的逻辑可以满足大部分预渲染的场景。但是，由于没有经过完善的测试，这样的逻辑依然隐藏了一些缺陷，导致预渲染失败甚至将已经预渲染的卡片误回收的错误。下面对以上改动需要额外进行的工作，带来的副作用产生的原因，以及副作用的修复过程进行说明。

主要的额外工作都在外界触发预渲染上。因为外界触发预渲染的时机不能保证，准确地说，无法确保外界触发预渲染时，RecyclerView 一定处于滚动停止状态。因此需要引入不同于超时补发预渲染机制的另一种补发预渲染的时机：当外界触发预渲染时，如果 RecyclerView 还不处于滚动停止状态，那么需要等到滚动停止时进行补发。这样做的一个主要原因是，在视频场景的 Feed 流中，通常外界触发预渲染的时机是视频起播的时机。但是视频起播通常和滚动停止互为异步行为。这样做的目的是为了优化起播的速度，用户滑动到当前视频，在卡片停稳之前就能做一些初始化的工作，从而让用户感觉视频的播放更加流畅。而如果视频起播时卡片仍然在滑动（性能越强的手机越容易出现这种情况），那么就违背了让预渲染任务避开卡片滑动事件的初心。因此需要做这样一个补发机制，来让外界触发的预渲染一定是在卡片静止时进行的。为此设置了如下标记位来记录外界触发预渲染模式下的特殊状态：

\begin{itemize}
    \item 是否给予短暂的额外布局空间：这个标记位只有预渲染任务触发时才设置为真。当用户再次滑动后，需要设置为假，以保证外界触发预渲染只会触发一次；
    \item 超时时间：当预渲染模式为带有超时补发机制的外界触发预渲染时，记录超时的时间。在这个时间之后，提交的预渲染任务会被执行。如果在超时时间之内已经有预渲染任务被执行，该任务会被取消；
    \item 不幸的外界尝试：当外界触发预渲染时，如果卡片仍处于滚动状态，会被设置为真。在下一次（通常是很短的时间之后）RecyclerView 滚动停止时，会针对这个不幸的尝试进行补发，并再次将标记位设置为假。
\end{itemize}

当 getExtraLayoutSpace() 被执行时，如果当前处于外界触发预渲染的模式，就会根据这些标记位来决定是否分发额外的布局空间。

在进行预渲染的测试时，发现了一个对性能影响很大，并且很容易触发的缺陷。如果 RecyclerView 的子 View 处理的触摸事件，那么如果此时有一个依赖于重置布局的动画在不断播放，那么已经被预渲染的卡片就会在滑动屏幕的一瞬间被回收，随后重新绑定。这样的动画在视频 Feed 流中非常常见。如点赞、收藏等互动的动效，一些广告的贴图，一些吸引用户点击的带有动效的按钮等等。由于我们无法规定业务方是否以重置布局的方式编写，所以我们只能默认这种情况很常见。其实不只是动画，任何重置布局的行为在滑动的一瞬间触发，都有可能导致已经被预渲染出的卡片被回收。因此，这个缺陷的原因是必须排查清除的。

通过 4.3 节我们知道，RecyclerView 在拦截 ACTION\_MOVE 事件时，会设置成滚动状态并拦截该事件。等到下一帧时，会由自己处理触摸事件，从而实现滑动的效果。但是，正是由于设置滚动状态和处理滚动处于不同的消息中，如果有不断触发的重置布局消息，这些消息就可能会被安排在拦截滚动事件和处理滚动事件的消息之间。因为这次布局处于滚动状态，在布局的时候 getExtraLayoutSpace() 就会返回默认值0。由于真实情况是屏幕并没有向下滚动任何距离，所以经过 LayoutManager 计算，已经被渲染出的卡片会被判定为脱离屏幕，从而被回收。

经过以上解释，我们能够清除，如果一个重置布局消息符合以上条件，应该具有如下特点：

\begin{itemize}
    \item RecyclerView 此时处于滚动状态；
    \item 当前处于 RecyclerView 的布局流程，而不是滑动流程；
    \item 屏幕并没有实际向下滚动。
\end{itemize}

根据这三个特点，我们就能够过滤出这样的重置布局消息，并给在这个时机给出额外的布局空间来避免卡片被回收。因此，需要设置 RecyclerView 是否处于布局流程的标记位，并记录本次滑动的滑动方向，通过第一个或者最后一个子 View 的布局参数来判断 RecyclerView 是否已经发生滚动。经过这样的修复，无论是在滚动停止时触发预渲染，还是外界触发的预渲染，都不会再出现已经预渲染的卡片被回收的副作用。

\subsection{实现卡片可见性分发}

当引入了预渲染机制后，原本的数据绑定生命周期会根据预渲染的模式而被提前执行。这会导致原本依赖于数据绑定即卡片可见的业务逻辑失效。这样的业务通常有曝光埋点、动画的起播逻辑、播放器的监听业务等。这些逻辑如果依然依赖于现在的数据绑定事件，会意外地在屏幕外被触发，从而再次带来性能上的损失，甚至数据错误。因此，需要引入一个新的生命周期来标识卡片的出现和消失，让依赖于这些时机的业务进行迁移。

卡片可见性的分发主要依赖于对目标卡片可见性的计算。如果计算出的卡片可见性和上次不同，则分发新的状态。这也就要求我们需要对每次计算出的卡片可见性进行记忆；另一个问题是，我们需要找到所有卡片可见性可能改变的时机，并在这个时机去触发相应卡片的可见性计算。

以上的问题经过研究给出如下的解决方案：卡片的可见性记忆采用 View 的 tag。因为对 ViewHolder 进行再次封装会增加业务方适配的难度，所以这里进行最小程度的改造。给 View 增加一个新的 tag，来标记该 View 上一次计算得到的可见性。如果发现新的可见性和上一次不同，则分发新的可见性并进行更新；卡片可见性的触发时机如下：

\begin{enumerate}
    \item 滚动触发时：因为会有新的 View 由于滚动而出现，已经存在的 View 因为滚动而消失；
    \item 当 View 由于自动回收、业务逻辑等原因被移除时：此时该 View 的可见性一定为false，无需进行计算；
    \item 当 RecyclerView 的布局流程完成时：针对通过 Adapter 的通知而导致的数据变动进行新的可见性计算。
\end{enumerate}

对于每一个卡片可见性的计算，具体的逻辑就是计算他在布局方向上是否已经离开屏幕。由于全屏视频场景中同时存在的卡片最多有两个，所以不会出现很大的性能损耗。

\section{预渲染优化验证}

只通过示例无法很好地对优化结果进行验证，同时我们目前还没有一个能够量化的流畅性指标来证明优化的程度。因此需要搭建一个相对真实的视频 Feed 流场景，并在次基础上建立准确、能够量化的流畅性指标来验证预渲染优化对流畅性体验的提升。

\subsection{搭建视频 Feed 流场景}

视频 Feed 流选用 RecyclerView 搭建，播放器选用谷歌的 Media 库，通过自定义视频展现的 View 来获取视频画面并播放。该案例中，通过解析本地文件夹中的视频，将它们平铺在列表中形成视频 Feed 流。用户上下滑动屏幕，即可与刷短视频一样浏览文件夹中的视频。同时，为了真实模拟短视频应用的体验，开发了沉浸式背景取色、松手起播、视频首帧图像作为视频封面等模块，让整体的体验更加像市面上的短视频应用。

接下来是验证优化结果的过程。为了引入卡顿，在视频卡片的 ViewHolder 绑定过程中人为引入一段耗时逻辑来模拟卡片进行数据绑定时的耗时操作。将视频 Feed 流的 LayoutManager 替换为我们引入了预渲染机制的版本，同时开启不同的模式来体验。我们引入的耗时逻辑越耗时，优化的体验就越明显。具体表现为：在没有预渲染的情况下，每一次滑动都会产生明显的卡顿，并且上滑的动画也出现了不同程度的调帧；在永远预渲染的模式下，只有第一次滑动是流畅的，其它的时候由于额外布局空间永远存在，滑动依然会产生卡顿；在滚动停止触发预渲染的模式下，只有滚动停止时才会进行预渲染，每一次滚动的流畅性都大大增加；在外界触发预渲染的情况下，只有视频开始播放并且滚动已经停止时才会触发预渲染。这意味着只要用户在视频播放之后才滑动屏幕，预渲染的卡片就一直存在，并且预渲染的逻辑也能够避开是视频起播的流程，最大程度地分散耗时任务的布局。

\subsection{流畅性指标建设}

能够量化的最直观的流畅性指标就是当前的实时帧率（FPS）。而实时帧率的计算是从 Android 屏幕刷新的过程以及 Choreographer 进行绘制流程得到的。在 API 24 之后，谷歌官方给出了统一的绘制帧情况的收集方法，通过注册 Window 的 onFrameMetricsAvailable() 回调，能够得到绘制的每一帧的信息。通过这些信息，我们能计算当前绘制行为持续的时间等情况，从而计算出帧率和其它的指标。在本案例下，我们计算的指标为长帧占比，即绘制时长超过两个 VSync 间隔的绘制行为在所有绘制行为中的比率。这个指标能够反映当前时间内绘制的流畅程度，长帧占比越高，卡顿的现象就更加严重。

在预渲染关闭和开启的情况下分别统计滑动完所有视频过程中的长帧占比，并控制不同的视频数量，得到如下结果：

\input{assets/preload-res}

可以发现，在预渲染开启的状态下，长帧占比明显降低，反映到体验上就是滑动行为更加流畅。