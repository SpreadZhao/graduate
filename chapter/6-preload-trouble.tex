\chapter{预渲染框架的缺陷及其修复过程}

在进行预渲染的测试时，发现了一个对性能影响很大，并且很容易触发的缺陷。如果 RecyclerView 的子 View 处理的触摸事件，那么如果此时有一个依赖于重置布局的动画在不断播放，那么已经被预渲染的卡片就会在滑动屏幕的一瞬间被回收，随后重新绑定。这样的动画在视频 Feed 流中非常常见。如点赞、收藏等互动的动效，一些广告的贴图，一些吸引用户点击的带有动效的按钮等等。由于我们无法规定业务方是否以重置布局的方式编写，所以我们只能默认这种情况很常见。其实不只是动画，任何重置布局的行为在滑动的一瞬间触发，都有可能导致已经被预渲染出的卡片被回收。因此，这个缺陷的原因是必须排查清除的。

卡片被回收的本质，从预渲染的框架设计中就能看出，一定是因为 getExtraLayoutSpace() 返回了默认值0，并且还是要在卡片没有滚动的状态下。只有上述条件全部被满足，RecyclerView 在布局的时候才会因为没有布局到先前预渲染出的卡片，从而将其回收。然而，用户在这个过程中已经传递了 ACTION\_MOVE 事件，意味着滚动行为已经开始。在这个过程中的布局流程，是一定能够布局到预渲染出的卡片的。这代表很可能有其它布局流程在这个过程中被插入到了滚动流程之前，同时 RecyclerView 此时也已经处于滚动状态。顺着这个思路排查，最终注意到了刚才提到的动画。在真实的业务场景中，屏幕上的很多动画都是通过触发布局流程实现的。改变 View 本身的参数，随后调用 requestLayout() 在下一帧中触发布局流程，从而实现动画的效果。这样的动画虽然会影响性能，但是实现简单，同时如果是简单的动效，对于大盘性能的影响不大。所以在大型项目中这样的动画很常见，并且发生的频率也很高。

根据上述发现，怀疑是业务场景中出现的动画影响了 RecyclerView 布局流程，从而导致卡片误回收。然而，在我自己开发的测试项目中进行复现，并没有出现卡片被回收的情况。所以进一步进行调研 RecyclerView 拦截滑动事件、处理滑动事件并设置滚动状态和开始滚动的全链路，找到其中隐藏的问题。

任何 View 处理滑动流程时，都需要处理 ACTION\_DOWN 事件、ACTION\_MOVE 事件和 ACTION\_UP 事件。通常，一个完整的滑动流程是一个 ACTION\_DOWN 加上若干个 ACTION\_MOVE 以及结尾的 ACTION\_UP。因此，对于 RecyclerView 来说，如何处理 ACTION\_DOWN 事件的走向尤为重要，这影响了后续事件的分发，自然也影响了整个的滑动流程。当 ACTION\_DOWN 事件产生时，RecyclerView 并不会拦截该事件，只会将事件传递给子 View。而子 View 可以自主选择是否消费该事件。如果子 View 没有消费 ACTION\_DOWN，那么将会由 RecyclerView 自己来消费。RecyclerView 本身永远会消费任何触摸事件，所以无法再继续向上传递。之后所有的 ACTION\_MOVE 事件以及最后的 ACTION\_UP 事件都会由 RecyclerView 自己来消费。这也是滑动流程中最理想的情况，完全由 RecyclerView 来主动控制。

但是，通常 RecyclerView 的子 View 是需要消费 ACTION\_DOWN 事件的。比如一个可以点击的新闻条目、一个视频条目等等。这些响应了点击事件的子 View 自然需要消费 ACTION\_DOWN 事件来处理点击过程。这也就导致了接下来的 ACTION\_MOVE 事件并不会被发送给 RecyclerView 来消费。那么在这种情况下，RecyclerView 应该如何处理滑动流程呢？答案是通过拦截。虽然 RecyclerView 接下来不会收到子 View 传递来的未经过消费的 ACTION\_MOVE 事件，但是在将其传递给子 View 之前，RecyclerView 本身也可以拦截该事件。因此，RecyclerView 在拦截的流程中，只要发现当前事件是 ACTION\_MOVE 事件，就会设置滑动状态的标记位，并拦截该事件。结果就是子 View 会收到 ACTION\_CANCEL 事件从而无法进行滑动处理（不进行嵌套滑动处理的条件下），而 RecyclerView 本身能够通过该方式消费 ACTION\_MOVE 事件以及最后的 ACTION\_UP 事件。虽然这样确实能够保证 RecyclerView 正常处理滑动流程，但是和直接处理不同，如果是通过拦截的方式处理 ACTION\_MOVE 事件，拦截的过程和真正进行滑动的过程会位于两个不同的消息，也就是两个不同的流程中。这样会导致如果中间被其他消息插入，会产生一些副作用。这部分也是我们在优化过程中需要重点克服的困难之一。

在真正进行滑动的过程中，会对每一次滑动事件进行解析。解析出的滑动距离、方向等属性会用于接下来的布局过程。RecyclerView 会对因为滑动而改变的子 View 进行重新的测量和布局，并尽可能复用已经被回收的 ViewHolder 来减少重复创建。对于新添加的子 View，也会通过 Adapter 进行数据绑定。

经过以上对源码的分析，我们知道，RecyclerView 在拦截 ACTION\_MOVE 事件时，会设置成滚动状态并拦截该事件。等到下一帧时，会由自己处理触摸事件，从而实现滑动的效果。但是，正是由于设置滚动状态和处理滚动处于不同的消息中，如果有不断触发的重置布局消息，这些消息就可能会被安排在拦截滚动事件和处理滚动事件的消息之间。因为这次布局处于滚动状态，在布局的时候 getExtraLayoutSpace() 就会返回默认值0。由于真实情况是屏幕并没有向下滚动任何距离，所以经过 LayoutManager 计算，已经被渲染出的卡片会被判定为脱离屏幕，从而被回收。

经过以上解释，我们能够清除，如果一个重置布局消息符合以上条件，应该具有如下特点：

\begin{itemize}
    \item RecyclerView 此时处于滚动状态；
    \item 当前处于 RecyclerView 的布局流程，而不是滑动流程；
    \item 屏幕并没有实际向下滚动。
\end{itemize}

根据这三个特点，我们就能够过滤出这样的重置布局消息，并给在这个时机给出额外的布局空间来避免卡片被回收。因此，需要设置 RecyclerView 是否处于布局流程的标记位，并记录本次滑动的滑动方向，通过第一个或者最后一个子 View 的布局参数来判断 RecyclerView 是否已经发生滚动。经过这样的修复，无论是在滚动停止时触发预渲染，还是外界触发的预渲染，都不会再出现已经预渲染的卡片被回收的副作用。